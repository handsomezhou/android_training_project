!SESSION 2014-03-18 09:10:35.734 -----------------------------------------------
eclipse.buildId=v22.3.0-887826
java.version=1.7.0_45
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=zh_CN
Framework arguments:  -product com.android.ide.eclipse.adt.package.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product com.android.ide.eclipse.adt.package.product

This is a continuation of log file D:\My Documents\GitHub\work\android_training_project\.metadata\.bak_9.log
Created Time: 2014-03-18 14:33:03.109

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:03.109
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:03.109
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:03.125
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:03.125
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:03.125
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:03.125
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:03.125
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:03.125
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:03.125
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:03.125
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:03.140
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:03.140
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:03.140
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:03.140
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:03.140
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:03.140
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:03.140
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:03.156
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:03.156
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:03.156
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:03.156
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:03.156
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:03.156
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:03.171
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:03.171
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:03.171
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:03.171
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:03.171
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:03.171
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:03.312
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:206)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:03.312
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:206)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:03.312
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:206)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:03.343
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:03.343
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:03.343
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:05.421
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:05.421
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:05.421
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:06.906
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:06.906
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:06.906
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:10.656
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:10.656
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:10.656
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:10.671
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:806)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getConstantValue(JavadocHover.java:749)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:682)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:612)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:565)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:557)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:10.671
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:806)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getConstantValue(JavadocHover.java:749)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:682)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:612)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:565)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:557)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:10.671
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:806)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getConstantValue(JavadocHover.java:749)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:682)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:612)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:565)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:557)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:10.796
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:10.796
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:10.812
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:10.812
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:806)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getConstantValue(JavadocHover.java:749)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:682)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:612)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:565)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:557)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:10.812
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:806)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getConstantValue(JavadocHover.java:749)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:682)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:612)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:565)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:557)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:10.812
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:806)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getConstantValue(JavadocHover.java:749)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:682)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:612)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:565)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:557)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:11.984
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:11.984
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:11.984
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:19.656
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-GRID_LEN)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:19.656
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:19.656
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:21.328
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-BLOCK_WIDTH)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:21.328
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:21.328
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:21.343
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-BLOCK_WIDTH)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:21.359
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:21.359
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:21.359
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-BLOCK_WIDTH)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:21.359
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:21.359
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:21.546
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-BLOCK_WIDTH)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:21.546
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:21.546
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:22.093
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-BLOCK_WIDTH)/2+1)
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:22.093
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:22.093
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:23.328
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-BLOCK_WIDTH)/2+1);
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:23.343
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:23.343
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:23.375
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-BLOCK_WIDTH)/2+1);
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:23.375
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:23.375
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:26.203
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X	((TETRIS_WIDTH-BLOCK_WIDTH)/2+1);
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:26.203
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:26.203
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:26.843
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X((TETRIS_WIDTH-BLOCK_WIDTH)/2+1);
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:26.843
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:26.843
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:246)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:203)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:518)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:26.875
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X((TETRIS_WIDTH-BLOCK_WIDTH)/2+1);
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:26.875
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:26.875
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.core 4 4 2014-03-18 14:33:27.640
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.example.tetris.object;

import android.content.Context;

public class GameConfig {

	/* 定义俄罗斯方块7种方块类型 */
	// public enum BlockType {
	// BLOCK_I, BLOCK_J, BLOCK_L, BLOCK_O, BLOCK_S, BLOCK_Z, BLOCK_T, _TYPE
	// }
	public class BlockType {
		public static final int BLOCK_I = 0;
		public static final int BLOCK_J = 1;
		public static final int BLOCK_L = 2;
		public static final int BLOCK_O = 3;
		public static final int BLOCK_S = 4;
		public static final int BLOCK_Z = 5;
		public static final int BLOCK_T = 6;
		public static final int BLOCK_TYPE = 7;
	}

	/* 俄罗斯方块中方块总类型数目 */
	public static final int BLOCK_TYPE_NUM = 7;

	public static final int BLOCK_WIDTH = 4;
	public static final int BLOCK_HEIGHT = 4;
	/* 俄罗斯方块每个方块的具体数目 */
	public static final int BLOCK_I_NUM = 2;
	public static final int BLOCK_J_NUM = 4;
	public static final int BLOCK_L_NUM = 4;
	public static final int BLOCK_O_NUM = 1;
	public static final int BLOCK_S_NUM = 2;
	public static final int BLOCK_Z_NUM = 2;
	public static final int BLOCK_T_NUM = 4;
	public final int BLOCK_SINGLE_MAX_NUM = 4;

	/* 俄罗斯方块中方块总数目 */
	public static final int BLOCK_TOTAL_NUM = 19; /*
												 * BLOCK_I_NUM+...+BLOCK_T_NUM
												 */
	/* 将俄罗斯方块中方块编号:BLOCK_X_START_NUM~BLOCK_X_NUM-1 代表X类型的方块所属编号 */
	public static final int BLOCK_I_START_NUM = 0;
	public static final int BLOCK_J_START_NUM = (BLOCK_I_START_NUM + BLOCK_I_NUM);
	public static final int BLOCK_L_START_NUM = (BLOCK_J_START_NUM + BLOCK_J_NUM);
	public static final int BLOCK_O_START_NUM = (BLOCK_L_START_NUM + BLOCK_L_NUM);
	public static final int BLOCK_S_START_NUM = (BLOCK_O_START_NUM + BLOCK_O_NUM);
	public static final int BLOCK_Z_START_NUM = (BLOCK_S_START_NUM + BLOCK_S_NUM);
	public static final int BLOCK_T_START_NUM = (BLOCK_Z_START_NUM + BLOCK_Z_NUM);

	public final int BLOCK_I0_MIN_X = 2;
	public final int BLOCK_I0_MIN_Y = 1;
	public final int BLOCK_I0_MAX_X = 2;
	public final int BLOCK_I0_MAX_Y = 4;

	public final int BLOCK_I1_MIN_X = 1;
	public final int BLOCK_I1_MIN_Y = 2;
	public final int BLOCK_I1_MAX_X = 4;
	public final int BLOCK_I1_MAX_Y = 2;

	public final int BLOCK_J0_MIN_X = 2;
	public final int BLOCK_J0_MIN_Y = 1;
	public final int BLOCK_J0_MAX_X = 3;
	public final int BLOCK_J0_MAX_Y = 3;

	public final int BLOCK_J1_MIN_X = 1;
	public final int BLOCK_J1_MAX_X = 3;
	public final int BLOCK_J1_MIN_Y = 1;
	public final int BLOCK_J1_MAX_Y = 2;
	public final int BLOCK_J2_MIN_X = 2;
	public final int BLOCK_J2_MIN_Y = 1;
	public final int BLOCK_J2_MAX_X = 3;
	public final int BLOCK_J2_MAX_Y = 3;

	public final int BLOCK_J3_MIN_X = 1;
	public final int BLOCK_J3_MIN_Y = 2;
	public final int BLOCK_J3_MAX_X = 3;
	public final int BLOCK_J3_MAX_Y = 3;

	public final int BLOCK_L0_MIN_X = 2;
	public final int BLOCK_L0_MIN_Y = 1;
	public final int BLOCK_L0_MAX_X = 3;
	public final int BLOCK_L0_MAX_Y = 3;

	public final int BLOCK_L1_MIN_X = 1;
	public final int BLOCK_L1_MIN_Y = 2;
	public final int BLOCK_L1_MAX_X = 3;
	public final int BLOCK_L1_MAX_Y = 3;

	public final int BLOCK_L2_MIN_X = 1;
	public final int BLOCK_L2_MIN_Y = 1;
	public final int BLOCK_L2_MAX_X = 2;
	public final int BLOCK_L2_MAX_Y = 3;

	public final int BLOCK_L3_MIN_X = 1;
	public final int BLOCK_L3_MIN_Y = 1;
	public final int BLOCK_L3_MAX_X = 3;
	public final int BLOCK_L3_MAX_Y = 2;

	public final int BLOCK_O0_MIN_X = 2;
	public final int BLOCK_O0_MIN_Y = 2;
	public final int BLOCK_O0_MAX_X = 3;
	public final int BLOCK_O0_MAX_Y = 3;

	public final int BLOCK_S0_MIN_X = 1;
	public final int BLOCK_S0_MIN_Y = 1;
	public final int BLOCK_S0_MAX_X = 3;
	public final int BLOCK_S0_MAX_Y = 2;

	public final int BLOCK_S1_MIN_X = 2;
	public final int BLOCK_S1_MIN_Y = 1;
	public final int BLOCK_S1_MAX_X = 3;
	public final int BLOCK_S1_MAX_Y = 3;

	public final int BLOCK_Z0_MIN_X = 1;
	public final int BLOCK_Z0_MIN_Y = 1;
	public final int BLOCK_Z0_MAX_X = 3;
	public final int BLOCK_Z0_MAX_Y = 2;

	public final int BLOCK_Z1_MIN_X = 2;
	public final int BLOCK_Z1_MIN_Y = 1;
	public final int BLOCK_Z1_MAX_X = 3;
	public final int BLOCK_Z1_MAX_Y = 3;

	public final int BLOCK_T0_MIN_X = 1;
	public final int BLOCK_T0_MIN_Y = 1;
	public final int BLOCK_T0_MAX_X = 3;
	public final int BLOCK_T0_MAX_Y = 2;

	public final int BLOCK_T1_MIN_X = 2;
	public final int BLOCK_T1_MIN_Y = 1;
	public final int BLOCK_T1_MAX_X = 3;
	public final int BLOCK_T1_MAX_Y = 3;

	public final int BLOCK_T2_MIN_X = 1;
	public final int BLOCK_T2_MIN_Y = 2;
	public final int BLOCK_T2_MAX_X = 3;
	public final int BLOCK_T2_MAX_Y = 3;

	public final int BLOCK_T3_MIN_X = 1;
	public final int BLOCK_T3_MIN_Y = 1;
	public final int BLOCK_T3_MAX_X = 2;
	public final int BLOCK_T3_MAX_Y = 3;

	private static final int BLOCK_TYPE_INIT = BlockType.BLOCK_TYPE;
	private static final char GRID_VALUE_1 = '1';
	private static final char GRID_VALUE_0 = '0';
	/* 俄罗斯方块界面的长和宽by default */
	private static final int TETRIS_HEIGHT = 20;
	private static final int TETRIS_WIDTH = 10;

	private static final char[][] block = {// [BLOCK_TOTAL_NUM][BLOCK_HEIGHT*BLOCK_WIDTH+1]
			// BLOCK_I
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'1', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_J
			{ '0', '0', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '1', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_L
			{ '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '1', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '1', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_O
			{ '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_S
			{ '0', '1', '1', '0', '1', '1', '0', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_Z
			{ '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '1', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },
			// BLOCK_T
			{ '0', '1', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '0', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '0', '0', '0', '1', '1', '1', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

			{ '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '0', '0', '0',
					'0', '0', '0', '\0', },

	};

	public final int TTRS_SUCCEED = 0;
	public final int TTRS_FAILED = -1;

	/* 初始化Block */
	public final int BLOCK_INIT_X = 0;
	public final int BLOCK_INIT_Y = 0;
	public final int BLOCK_ERROR_TYPE = -1;
	public final int BLOCK_ERROR_NUM = -1;

	public final int CUR_BLOCK_INIT_Y =-3;
	public final int CUR_BLOCK_INIT_X ((TETRIS_WIDTH-BLOCK_WIDTH)/2+1);
	
	public enum GameStatus {
		STATUS_INIT, STATUS_PLAYING, STATUS_PAUSE, STATUS_QUIT
	}

	/* 游戏状态 */
	public GameStatus gameStatus;
	/* 游戏等级 */
	private int gameLevel;
	/* 游戏分数 */
	private int gameScore;
	// Block[y][x]数组第一二维的长度
	private int xSize;
	private int ySize;
	// Board中第一张图片出现的x座标与y座标
	private int beginImageX;
	private int beginImageY;
	// Block 小方块图片的宽和高
	private int imageWidth;
	private int imageHeight;

	// CurBlock 第一次出现的位置
	private int curBlockInitY;
	private int curBlockInitX;

	private Context context;

	public GameConfig(int beginImageY, int beginImageX, int imageHeight,
			int imageWidth, Context context) {
		this.ySize = TETRIS_HEIGHT;
		this.xSize = TETRIS_WIDTH;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	/**
	 * 
	 * @param tetrisHeight
	 *            俄罗斯方块的高(行)
	 * @param tetrisWidth
	 *            俄罗斯方块的宽度(列)
	 * @param beginImageY
	 *            最左上角显示的小方块,相对于方块显示区域的Y偏移量
	 * @param beginImageX
	 *            最左上角显示的小方块,相对于方块显示区域的X偏移量
	 * @param imageHeight
	 *            小方块的高
	 * @param imageWidth
	 *            小方块的宽
	 * @param context
	 */
	public GameConfig(int tetrisHeight, int tetrisWidth, int beginImageY,
			int beginImageX, int imageHeight, int imageWidth, Context context) {
		this.gameStatus = GameStatus.STATUS_INIT;
		this.gameLevel = 1;
		this.gameScore = 0;
		this.ySize = tetrisHeight;
		this.xSize = tetrisWidth;
		this.beginImageY = beginImageY;
		this.beginImageX = beginImageX;
		this.imageHeight = imageHeight;
		this.imageWidth = imageWidth;
		this.context = context;
	}

	public void setGameStatus(GameStatus gameStatus) {
		this.gameStatus = gameStatus;
	}

	public GameStatus getGameStatus() {
		return this.gameStatus;
	}

	public void setGameLevel(int gameLevel) {
		this.gameLevel = gameLevel;
	}

	public int getGameLevel() {
		return this.gameLevel;
	}

	public void setGameScore(int gameScore) {
		this.gameScore = gameScore;
	}

	public int getGameScore() {
		return this.gameScore;
	}

	public int getBlockTypeNUM() {
		return BLOCK_TYPE_NUM;
	}

	public int getBlockHeight() {
		return BLOCK_HEIGHT;
	}

	public int getBlockWidth() {
		return BLOCK_WIDTH;
	}

	public int getBlockInitType() {

		return BLOCK_TYPE_INIT;
	}

	public char getValueOne() {
		return GRID_VALUE_1;
	}

	public char getValueZero() {
		return GRID_VALUE_0;
	}

	public char[] getBlocks(int index) {
		return block[index];
	}

	/*
	 * public char[] copyBlockData(char[] dst, char[] scr, int size) { for (int
	 * i = 0; i < size; i++) { dst[i] = scr[i]; }
	 * 
	 * return dst; }
	 */

	public void setXSize(int xSize) {
		this.xSize = xSize;
	}

	public int getXSize() {
		return this.xSize;
	}

	public void setYSize(int ySize) {
		this.ySize = ySize;
	}

	public int getYSize() {
		return this.ySize;
	}

	public void setBeginImageY(int beginImageY) {
		this.beginImageY = beginImageY;
	}

	public int getBeginImageY() {
		return this.beginImageY;
	}

	public void setBeginImageX(int beginImageX) {
		this.beginImageX = beginImageX;
	}

	public int getBeginImageX() {
		return this.beginImageX;
	}

	public void setImageWidth(int imageWidth) {
		this.imageWidth = imageWidth;
	}

	public int getImageWidth() {
		return this.imageWidth;
	}

	public void setImageHeight(int imageHeight) {
		this.imageHeight = imageHeight;
	}

	public int getImageHeight() {
		return this.imageHeight;
	}

	public void setCurBlockInitY(int curBlockInitY) {
		this.curBlockInitY = curBlockInitY;
	}

	public int getCurBlockInitY() {
		return this.curBlockInitY;
	}

	public void setCurBlockInitX(int curBlockInitX) {
		this.curBlockInitX = curBlockInitX;
	}

	public int getCurBlockInitX() {
		return this.curBlockInitX;
	}

	public Context getContext() {
		return context;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 2 2014-03-18 14:33:27.640
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jdt.ui 4 0 2014-03-18 14:33:27.640
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2648)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1396)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:246)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:2853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2594)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2426)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:534)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:183)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2656)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1219)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:291)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1207)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY org.eclipse.jface 2 0 2014-03-18 15:30:11.062
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2014-03-18 15:30:11.062
!MESSAGE A conflict occurred for CTRL+I:
Binding(CTRL+I,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.indent,Correct Indentation,
		Corrects the indentation of the selected lines,
		Category(org.eclipse.jdt.ui.category.source,Source,Java Source Actions,true),
		org.eclipse.ui.internal.MakeHandlersGo@65b30f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+I,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.format.active.elements,Format Active Elements,
		Format active elements,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@19b43a9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2014-03-18 15:30:11.062
!MESSAGE A conflict occurred for CTRL+SHIFT+F:
Binding(CTRL+SHIFT+F,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.format,Format,
		Format the selected text,
		Category(org.eclipse.jdt.ui.category.source,Source,Java Source Actions,true),
		org.eclipse.ui.internal.MakeHandlersGo@a3c1cb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+SHIFT+F,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.format.document,Format,
		Format selection,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@b4e3a8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2014-03-18 15:30:11.062
!MESSAGE A conflict occurred for CTRL+SHIFT+ARROW_DOWN:
Binding(CTRL+SHIFT+ARROW_DOWN,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.goto.next.member,Go to Next Member,
		Move the caret to the next member of the compilation unit,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@cea424,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+SHIFT+ARROW_DOWN,
	ParameterizedCommand(Command(org.eclipse.wst.xml.ui.nextSibling,Next Sibling,
		Go to Next Sibling,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@11db933,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2014-03-18 15:30:11.062
!MESSAGE A conflict occurred for ALT+SHIFT+ARROW_LEFT:
Binding(ALT+SHIFT+ARROW_LEFT,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.select.previous,Select Previous Element,
		Expand selection to include previous sibling,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@7a6d3d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(ALT+SHIFT+ARROW_LEFT,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.structure.select.previous,Select Previous Element,
		Expand selection to include previous sibling,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@3fc886,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2014-03-18 15:30:11.062
!MESSAGE A conflict occurred for ALT+SHIFT+ARROW_UP:
Binding(ALT+SHIFT+ARROW_UP,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.select.enclosing,Select Enclosing Element,
		Expand selection to include enclosing element,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@199ec25,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(ALT+SHIFT+ARROW_UP,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.structure.select.enclosing,Select Enclosing Element,
		Expand selection to include enclosing element,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@1344f4c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2014-03-18 15:30:11.062
!MESSAGE A conflict occurred for CTRL+SHIFT+P:
Binding(CTRL+SHIFT+P,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.goto.matching.bracket,Go to Matching Bracket,
		Moves the cursor to the matching bracket,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@5eb295,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+SHIFT+P,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.goto.matching.bracket,Matching Bracket,
		Go to Matching Bracket,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@dbebe1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2014-03-18 15:30:11.062
!MESSAGE A conflict occurred for CTRL+SHIFT+/:
Binding(CTRL+SHIFT+/,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.add.block.comment,Add Block Comment,
		Enclose the selection with a block comment,
		Category(org.eclipse.jdt.ui.category.source,Source,Java Source Actions,true),
		org.eclipse.ui.internal.MakeHandlersGo@11e7e72,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+SHIFT+/,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.add.block.comment,Add Block Comment,
		Add Block Comment,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@d1ce8e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2014-03-18 15:30:11.062
!MESSAGE A conflict occurred for CTRL+O:
Binding(CTRL+O,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.show.outline,Quick Outline,
		Show the quick outline for the editor input,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@ff92d8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+O,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.quick_outline,Quick Outline,
		Show the quick outline for the editor input,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@101b4db,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2014-03-18 15:30:11.062
!MESSAGE A conflict occurred for CTRL+SHIFT+ARROW_UP:
Binding(CTRL+SHIFT+ARROW_UP,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.goto.previous.member,Go to Previous Member,
		Move the caret to the previous member of the compilation unit,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@108b31a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+SHIFT+ARROW_UP,
	ParameterizedCommand(Command(org.eclipse.wst.xml.ui.previousSibling,Previous Sibling,
		Go to Previous Sibling,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@1c58032,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2014-03-18 15:30:11.062
!MESSAGE A conflict occurred for ALT+SHIFT+ARROW_DOWN:
Binding(ALT+SHIFT+ARROW_DOWN,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.select.last,Restore Last Selection,
		Restore last selection,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@267fe0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(ALT+SHIFT+ARROW_DOWN,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.structure.select.last,Restore Last Selection,
		Restore last selection,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@1cf629f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2014-03-18 15:30:11.062
!MESSAGE A conflict occurred for CTRL+SHIFT+C:
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.toggle.comment,Toggle Comment,
		Toggle comment the selected lines,
		Category(org.eclipse.jdt.ui.category.source,Source,Java Source Actions,true),
		org.eclipse.ui.internal.MakeHandlersGo@17dbe0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.toggle.comment,Toggle Comment,
		Toggle Comment,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@1b6152b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2014-03-18 15:30:11.062
!MESSAGE A conflict occurred for ALT+SHIFT+ARROW_RIGHT:
Binding(ALT+SHIFT+ARROW_RIGHT,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.select.next,Select Next Element,
		Expand selection to include next sibling,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@19586b3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(ALT+SHIFT+ARROW_RIGHT,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.structure.select.next,Select Next Element,
		Expand selection to include next sibling,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@1cee6cb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2014-03-18 15:30:11.062
!MESSAGE A conflict occurred for CTRL+SHIFT+\:
Binding(CTRL+SHIFT+\,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.remove.block.comment,Remove Block Comment,
		Remove the block comment enclosing the selection,
		Category(org.eclipse.jdt.ui.category.source,Source,Java Source Actions,true),
		org.eclipse.ui.internal.MakeHandlersGo@1be57b6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.jdt.ui.javaEditorScope,,,system)
Binding(CTRL+SHIFT+\,
	ParameterizedCommand(Command(org.eclipse.wst.sse.ui.remove.block.comment,Remove Block Comment,
		Remove Block Comment,
		Category(org.eclipse.ui.category.edit,Edit,null,true),
		org.eclipse.ui.internal.MakeHandlersGo@af31ae,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.wst.sse.ui.structuredTextEditorScope,,,system)

!ENTRY com.android.ide.eclipse.adt 4 0 2014-03-18 15:46:05.562
!MESSAGE No command output when running: 'am start -n com.example.tetris/com.example.tetris.Tetris -a android.intent.action.MAIN -c android.intent.category.LAUNCHER' on device sp-64c50cb2
!STACK 0
com.android.ddmlib.ShellCommandUnresponsiveException
	at com.android.ddmlib.AdbHelper.executeRemoteCommand(AdbHelper.java:430)
	at com.android.ddmlib.AdbHelper.executeRemoteCommand(AdbHelper.java:347)
	at com.android.ddmlib.Device.executeShellCommand(Device.java:435)
	at com.android.ide.eclipse.adt.internal.launch.ActivityLaunchAction.doLaunchAction(ActivityLaunchAction.java:67)
	at com.android.ide.eclipse.adt.internal.launch.ActivityLaunchAction.doLaunchAction(ActivityLaunchAction.java:109)
	at com.android.ide.eclipse.adt.internal.launch.AndroidLaunchController.doLaunchAction(AndroidLaunchController.java:1286)
	at com.android.ide.eclipse.adt.internal.launch.AndroidLaunchController.doLaunchAction(AndroidLaunchController.java:1298)
	at com.android.ide.eclipse.adt.internal.launch.AndroidLaunchController.launchApp(AndroidLaunchController.java:1270)
	at com.android.ide.eclipse.adt.internal.launch.AndroidLaunchController.simpleLaunch(AndroidLaunchController.java:906)
	at com.android.ide.eclipse.adt.internal.launch.AndroidLaunchController.continueLaunch(AndroidLaunchController.java:748)
	at com.android.ide.eclipse.adt.internal.launch.AndroidLaunchController.launch(AndroidLaunchController.java:640)
	at com.android.ide.eclipse.adt.internal.launch.LaunchConfigDelegate.doLaunch(LaunchConfigDelegate.java:322)
	at com.android.ide.eclipse.adt.internal.launch.LaunchConfigDelegate.launch(LaunchConfigDelegate.java:238)
	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:855)
	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:704)
	at org.eclipse.debug.internal.ui.DebugUIPlugin.buildAndLaunch(DebugUIPlugin.java:1047)
	at org.eclipse.debug.internal.ui.DebugUIPlugin$8.run(DebugUIPlugin.java:1251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

!ENTRY com.android.ide.eclipse.adt 4 0 2014-03-18 21:09:32.687
!MESSAGE Failed converting ECJ parse tree to Lombok for file D:\My Documents\GitHub\work\android_training_project\Tetris\src\com\example\tetris\service\implement\GameServiceImplement.java
!STACK 0
java.lang.NullPointerException: returnTypeReference is mandatory
	at lombok.ast.MethodDeclaration.astReturnTypeReference(MethodDeclaration.java:75)
	at lombok.ast.ecj.EcjTreeConverter$2.visitMethodDeclaration(EcjTreeConverter.java:1231)
	at lombok.ast.ecj.EcjTreeVisitor.visitEcjNode(EcjTreeVisitor.java:152)
	at lombok.ast.ecj.EcjTreeConverter.visit(EcjTreeConverter.java:290)
	at lombok.ast.ecj.EcjTreeConverter.toTree(EcjTreeConverter.java:231)
	at lombok.ast.ecj.EcjTreeConverter.fillList(EcjTreeConverter.java:277)
	at lombok.ast.ecj.EcjTreeConverter.fillList(EcjTreeConverter.java:247)
	at lombok.ast.ecj.EcjTreeConverter.access$100(EcjTreeConverter.java:140)
	at lombok.ast.ecj.EcjTreeConverter$2.createNormalTypeBody(EcjTreeConverter.java:557)
	at lombok.ast.ecj.EcjTreeConverter$2.visitTypeDeclaration(EcjTreeConverter.java:480)
	at lombok.ast.ecj.EcjTreeVisitor.visitEcjNode(EcjTreeVisitor.java:48)
	at lombok.ast.ecj.EcjTreeConverter.visit(EcjTreeConverter.java:290)
	at lombok.ast.ecj.EcjTreeConverter.toTree(EcjTreeConverter.java:231)
	at lombok.ast.ecj.EcjTreeConverter.fillList(EcjTreeConverter.java:277)
	at lombok.ast.ecj.EcjTreeConverter.fillList(EcjTreeConverter.java:247)
	at lombok.ast.ecj.EcjTreeConverter.access$100(EcjTreeConverter.java:140)
	at lombok.ast.ecj.EcjTreeConverter$2.visitCompilationUnitDeclaration(EcjTreeConverter.java:435)
	at lombok.ast.ecj.EcjTreeVisitor.visitEcjNode(EcjTreeVisitor.java:264)
	at lombok.ast.ecj.EcjTreeConverter.visit(EcjTreeConverter.java:290)
	at com.android.ide.eclipse.adt.internal.lint.EclipseLintClient$EclipseJavaParser.parseJava(EclipseLintClient.java:1142)
	at com.android.tools.lint.client.api.JavaVisitor.visitFile(JavaVisitor.java:196)
	at com.android.tools.lint.client.api.LintDriver.checkIndividualJavaFiles(LintDriver.java:1568)
	at com.android.tools.lint.client.api.LintDriver.runFileDetectors(LintDriver.java:965)
	at com.android.tools.lint.client.api.LintDriver.checkProject(LintDriver.java:842)
	at com.android.tools.lint.client.api.LintDriver.analyze(LintDriver.java:416)
	at com.android.tools.lint.client.api.LintDriver.analyze(LintDriver.java:363)
	at com.android.ide.eclipse.adt.internal.lint.LintJob.run(LintJob.java:163)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)
